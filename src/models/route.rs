/* 
 * Strava API v3
 *
 * The [Swagger Playground](https://developers.strava.com/playground) is the easiest way to familiarize yourself with the Strava API by submitting HTTP requests and observing the responses before you write any client code. It will show what a response will look like with different endpoints depending on the authorization scope you receive from your athletes. To use the Playground, go to https://www.strava.com/settings/api and change your “Authorization Callback Domain” to developers.strava.com. Please note, we only support Swagger 2.0. There is a known issue where you can only select one scope at a time. For more information, please check the section “client code” at https://developers.strava.com/docs.
 *
 * OpenAPI spec version: 3.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct Route {
  #[serde(rename = "athlete")]
  athlete: Option<::models::SummaryAthlete>,
  /// The description of the route
  #[serde(rename = "description")]
  description: Option<String>,
  /// The route's distance, in meters
  #[serde(rename = "distance")]
  distance: Option<f32>,
  /// The route's elevation gain.
  #[serde(rename = "elevation_gain")]
  elevation_gain: Option<f32>,
  /// The unique identifier of this route
  #[serde(rename = "id")]
  id: Option<i32>,
  #[serde(rename = "map")]
  map: Option<::models::PolylineMap>,
  /// The name of this route
  #[serde(rename = "name")]
  name: Option<String>,
  /// Whether this route is private
  #[serde(rename = "private")]
  private: Option<bool>,
  /// Whether this route is starred by the logged-in athlete
  #[serde(rename = "starred")]
  starred: Option<bool>,
  /// An epoch timestamp of when the route was created
  #[serde(rename = "timestamp")]
  timestamp: Option<i32>,
  /// This route's type (1 for ride, 2 for runs)
  #[serde(rename = "type")]
  _type: Option<i32>,
  /// This route's sub-type (1 for road, 2 for mountain bike, 3 for cross, 4 for trail, 5 for mixed)
  #[serde(rename = "sub_type")]
  sub_type: Option<i32>,
  /// The segments traversed by this route
  #[serde(rename = "segments")]
  segments: Option<Vec<::models::SummarySegment>>
}

impl Route {
  pub fn new() -> Route {
    Route {
      athlete: None,
      description: None,
      distance: None,
      elevation_gain: None,
      id: None,
      map: None,
      name: None,
      private: None,
      starred: None,
      timestamp: None,
      _type: None,
      sub_type: None,
      segments: None
    }
  }

  pub fn set_athlete(&mut self, athlete: ::models::SummaryAthlete) {
    self.athlete = Some(athlete);
  }

  pub fn with_athlete(mut self, athlete: ::models::SummaryAthlete) -> Route {
    self.athlete = Some(athlete);
    self
  }

  pub fn athlete(&self) -> Option<&::models::SummaryAthlete> {
    self.athlete.as_ref()
  }

  pub fn reset_athlete(&mut self) {
    self.athlete = None;
  }

  pub fn set_description(&mut self, description: String) {
    self.description = Some(description);
  }

  pub fn with_description(mut self, description: String) -> Route {
    self.description = Some(description);
    self
  }

  pub fn description(&self) -> Option<&String> {
    self.description.as_ref()
  }

  pub fn reset_description(&mut self) {
    self.description = None;
  }

  pub fn set_distance(&mut self, distance: f32) {
    self.distance = Some(distance);
  }

  pub fn with_distance(mut self, distance: f32) -> Route {
    self.distance = Some(distance);
    self
  }

  pub fn distance(&self) -> Option<&f32> {
    self.distance.as_ref()
  }

  pub fn reset_distance(&mut self) {
    self.distance = None;
  }

  pub fn set_elevation_gain(&mut self, elevation_gain: f32) {
    self.elevation_gain = Some(elevation_gain);
  }

  pub fn with_elevation_gain(mut self, elevation_gain: f32) -> Route {
    self.elevation_gain = Some(elevation_gain);
    self
  }

  pub fn elevation_gain(&self) -> Option<&f32> {
    self.elevation_gain.as_ref()
  }

  pub fn reset_elevation_gain(&mut self) {
    self.elevation_gain = None;
  }

  pub fn set_id(&mut self, id: i32) {
    self.id = Some(id);
  }

  pub fn with_id(mut self, id: i32) -> Route {
    self.id = Some(id);
    self
  }

  pub fn id(&self) -> Option<&i32> {
    self.id.as_ref()
  }

  pub fn reset_id(&mut self) {
    self.id = None;
  }

  pub fn set_map(&mut self, map: ::models::PolylineMap) {
    self.map = Some(map);
  }

  pub fn with_map(mut self, map: ::models::PolylineMap) -> Route {
    self.map = Some(map);
    self
  }

  pub fn map(&self) -> Option<&::models::PolylineMap> {
    self.map.as_ref()
  }

  pub fn reset_map(&mut self) {
    self.map = None;
  }

  pub fn set_name(&mut self, name: String) {
    self.name = Some(name);
  }

  pub fn with_name(mut self, name: String) -> Route {
    self.name = Some(name);
    self
  }

  pub fn name(&self) -> Option<&String> {
    self.name.as_ref()
  }

  pub fn reset_name(&mut self) {
    self.name = None;
  }

  pub fn set_private(&mut self, private: bool) {
    self.private = Some(private);
  }

  pub fn with_private(mut self, private: bool) -> Route {
    self.private = Some(private);
    self
  }

  pub fn private(&self) -> Option<&bool> {
    self.private.as_ref()
  }

  pub fn reset_private(&mut self) {
    self.private = None;
  }

  pub fn set_starred(&mut self, starred: bool) {
    self.starred = Some(starred);
  }

  pub fn with_starred(mut self, starred: bool) -> Route {
    self.starred = Some(starred);
    self
  }

  pub fn starred(&self) -> Option<&bool> {
    self.starred.as_ref()
  }

  pub fn reset_starred(&mut self) {
    self.starred = None;
  }

  pub fn set_timestamp(&mut self, timestamp: i32) {
    self.timestamp = Some(timestamp);
  }

  pub fn with_timestamp(mut self, timestamp: i32) -> Route {
    self.timestamp = Some(timestamp);
    self
  }

  pub fn timestamp(&self) -> Option<&i32> {
    self.timestamp.as_ref()
  }

  pub fn reset_timestamp(&mut self) {
    self.timestamp = None;
  }

  pub fn set__type(&mut self, _type: i32) {
    self._type = Some(_type);
  }

  pub fn with__type(mut self, _type: i32) -> Route {
    self._type = Some(_type);
    self
  }

  pub fn _type(&self) -> Option<&i32> {
    self._type.as_ref()
  }

  pub fn reset__type(&mut self) {
    self._type = None;
  }

  pub fn set_sub_type(&mut self, sub_type: i32) {
    self.sub_type = Some(sub_type);
  }

  pub fn with_sub_type(mut self, sub_type: i32) -> Route {
    self.sub_type = Some(sub_type);
    self
  }

  pub fn sub_type(&self) -> Option<&i32> {
    self.sub_type.as_ref()
  }

  pub fn reset_sub_type(&mut self) {
    self.sub_type = None;
  }

  pub fn set_segments(&mut self, segments: Vec<::models::SummarySegment>) {
    self.segments = Some(segments);
  }

  pub fn with_segments(mut self, segments: Vec<::models::SummarySegment>) -> Route {
    self.segments = Some(segments);
    self
  }

  pub fn segments(&self) -> Option<&Vec<::models::SummarySegment>> {
    self.segments.as_ref()
  }

  pub fn reset_segments(&mut self) {
    self.segments = None;
  }

}



