/* 
 * Strava API v3
 *
 * The [Swagger Playground](https://developers.strava.com/playground) is the easiest way to familiarize yourself with the Strava API by submitting HTTP requests and observing the responses before you write any client code. It will show what a response will look like with different endpoints depending on the authorization scope you receive from your athletes. To use the Playground, go to https://www.strava.com/settings/api and change your “Authorization Callback Domain” to developers.strava.com. Please note, we only support Swagger 2.0. There is a known issue where you can only select one scope at a time. For more information, please check the section “client code” at https://developers.strava.com/docs.
 *
 * OpenAPI spec version: 3.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct ActivityZone {
  #[serde(rename = "score")]
  score: Option<i32>,
  #[serde(rename = "distribution_buckets")]
  distribution_buckets: Option<::models::TimedZoneDistribution>,
  #[serde(rename = "type")]
  _type: Option<String>,
  #[serde(rename = "sensor_based")]
  sensor_based: Option<bool>,
  #[serde(rename = "points")]
  points: Option<i32>,
  #[serde(rename = "custom_zones")]
  custom_zones: Option<bool>,
  #[serde(rename = "max")]
  max: Option<i32>
}

impl ActivityZone {
  pub fn new() -> ActivityZone {
    ActivityZone {
      score: None,
      distribution_buckets: None,
      _type: None,
      sensor_based: None,
      points: None,
      custom_zones: None,
      max: None
    }
  }

  pub fn set_score(&mut self, score: i32) {
    self.score = Some(score);
  }

  pub fn with_score(mut self, score: i32) -> ActivityZone {
    self.score = Some(score);
    self
  }

  pub fn score(&self) -> Option<&i32> {
    self.score.as_ref()
  }

  pub fn reset_score(&mut self) {
    self.score = None;
  }

  pub fn set_distribution_buckets(&mut self, distribution_buckets: ::models::TimedZoneDistribution) {
    self.distribution_buckets = Some(distribution_buckets);
  }

  pub fn with_distribution_buckets(mut self, distribution_buckets: ::models::TimedZoneDistribution) -> ActivityZone {
    self.distribution_buckets = Some(distribution_buckets);
    self
  }

  pub fn distribution_buckets(&self) -> Option<&::models::TimedZoneDistribution> {
    self.distribution_buckets.as_ref()
  }

  pub fn reset_distribution_buckets(&mut self) {
    self.distribution_buckets = None;
  }

  pub fn set__type(&mut self, _type: String) {
    self._type = Some(_type);
  }

  pub fn with__type(mut self, _type: String) -> ActivityZone {
    self._type = Some(_type);
    self
  }

  pub fn _type(&self) -> Option<&String> {
    self._type.as_ref()
  }

  pub fn reset__type(&mut self) {
    self._type = None;
  }

  pub fn set_sensor_based(&mut self, sensor_based: bool) {
    self.sensor_based = Some(sensor_based);
  }

  pub fn with_sensor_based(mut self, sensor_based: bool) -> ActivityZone {
    self.sensor_based = Some(sensor_based);
    self
  }

  pub fn sensor_based(&self) -> Option<&bool> {
    self.sensor_based.as_ref()
  }

  pub fn reset_sensor_based(&mut self) {
    self.sensor_based = None;
  }

  pub fn set_points(&mut self, points: i32) {
    self.points = Some(points);
  }

  pub fn with_points(mut self, points: i32) -> ActivityZone {
    self.points = Some(points);
    self
  }

  pub fn points(&self) -> Option<&i32> {
    self.points.as_ref()
  }

  pub fn reset_points(&mut self) {
    self.points = None;
  }

  pub fn set_custom_zones(&mut self, custom_zones: bool) {
    self.custom_zones = Some(custom_zones);
  }

  pub fn with_custom_zones(mut self, custom_zones: bool) -> ActivityZone {
    self.custom_zones = Some(custom_zones);
    self
  }

  pub fn custom_zones(&self) -> Option<&bool> {
    self.custom_zones.as_ref()
  }

  pub fn reset_custom_zones(&mut self) {
    self.custom_zones = None;
  }

  pub fn set_max(&mut self, max: i32) {
    self.max = Some(max);
  }

  pub fn with_max(mut self, max: i32) -> ActivityZone {
    self.max = Some(max);
    self
  }

  pub fn max(&self) -> Option<&i32> {
    self.max.as_ref()
  }

  pub fn reset_max(&mut self) {
    self.max = None;
  }

}



