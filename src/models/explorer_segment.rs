/* 
 * Strava API v3
 *
 * The [Swagger Playground](https://developers.strava.com/playground) is the easiest way to familiarize yourself with the Strava API by submitting HTTP requests and observing the responses before you write any client code. It will show what a response will look like with different endpoints depending on the authorization scope you receive from your athletes. To use the Playground, go to https://www.strava.com/settings/api and change your “Authorization Callback Domain” to developers.strava.com. Please note, we only support Swagger 2.0. There is a known issue where you can only select one scope at a time. For more information, please check the section “client code” at https://developers.strava.com/docs.
 *
 * OpenAPI spec version: 3.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct ExplorerSegment {
  /// The unique identifier of this segment
  #[serde(rename = "id")]
  id: Option<i64>,
  /// The name of this segment
  #[serde(rename = "name")]
  name: Option<String>,
  /// The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catégorie, 0 is uncategorized in climb_category. If climb_category = 5, climb_category_desc = HC. If climb_category = 2, climb_category_desc = 3.
  #[serde(rename = "climb_category")]
  climb_category: Option<i32>,
  /// The description for the category of the climb
  #[serde(rename = "climb_category_desc")]
  climb_category_desc: Option<String>,
  /// The segment's average grade, in percents
  #[serde(rename = "avg_grade")]
  avg_grade: Option<f32>,
  #[serde(rename = "start_latlng")]
  start_latlng: Option<::models::LatLng>,
  #[serde(rename = "end_latlng")]
  end_latlng: Option<::models::LatLng>,
  /// The segments's evelation difference, in meters
  #[serde(rename = "elev_difference")]
  elev_difference: Option<f32>,
  /// The segment's distance, in meters
  #[serde(rename = "distance")]
  distance: Option<f32>,
  /// The polyline of the segment
  #[serde(rename = "points")]
  points: Option<String>
}

impl ExplorerSegment {
  pub fn new() -> ExplorerSegment {
    ExplorerSegment {
      id: None,
      name: None,
      climb_category: None,
      climb_category_desc: None,
      avg_grade: None,
      start_latlng: None,
      end_latlng: None,
      elev_difference: None,
      distance: None,
      points: None
    }
  }

  pub fn set_id(&mut self, id: i64) {
    self.id = Some(id);
  }

  pub fn with_id(mut self, id: i64) -> ExplorerSegment {
    self.id = Some(id);
    self
  }

  pub fn id(&self) -> Option<&i64> {
    self.id.as_ref()
  }

  pub fn reset_id(&mut self) {
    self.id = None;
  }

  pub fn set_name(&mut self, name: String) {
    self.name = Some(name);
  }

  pub fn with_name(mut self, name: String) -> ExplorerSegment {
    self.name = Some(name);
    self
  }

  pub fn name(&self) -> Option<&String> {
    self.name.as_ref()
  }

  pub fn reset_name(&mut self) {
    self.name = None;
  }

  pub fn set_climb_category(&mut self, climb_category: i32) {
    self.climb_category = Some(climb_category);
  }

  pub fn with_climb_category(mut self, climb_category: i32) -> ExplorerSegment {
    self.climb_category = Some(climb_category);
    self
  }

  pub fn climb_category(&self) -> Option<&i32> {
    self.climb_category.as_ref()
  }

  pub fn reset_climb_category(&mut self) {
    self.climb_category = None;
  }

  pub fn set_climb_category_desc(&mut self, climb_category_desc: String) {
    self.climb_category_desc = Some(climb_category_desc);
  }

  pub fn with_climb_category_desc(mut self, climb_category_desc: String) -> ExplorerSegment {
    self.climb_category_desc = Some(climb_category_desc);
    self
  }

  pub fn climb_category_desc(&self) -> Option<&String> {
    self.climb_category_desc.as_ref()
  }

  pub fn reset_climb_category_desc(&mut self) {
    self.climb_category_desc = None;
  }

  pub fn set_avg_grade(&mut self, avg_grade: f32) {
    self.avg_grade = Some(avg_grade);
  }

  pub fn with_avg_grade(mut self, avg_grade: f32) -> ExplorerSegment {
    self.avg_grade = Some(avg_grade);
    self
  }

  pub fn avg_grade(&self) -> Option<&f32> {
    self.avg_grade.as_ref()
  }

  pub fn reset_avg_grade(&mut self) {
    self.avg_grade = None;
  }

  pub fn set_start_latlng(&mut self, start_latlng: ::models::LatLng) {
    self.start_latlng = Some(start_latlng);
  }

  pub fn with_start_latlng(mut self, start_latlng: ::models::LatLng) -> ExplorerSegment {
    self.start_latlng = Some(start_latlng);
    self
  }

  pub fn start_latlng(&self) -> Option<&::models::LatLng> {
    self.start_latlng.as_ref()
  }

  pub fn reset_start_latlng(&mut self) {
    self.start_latlng = None;
  }

  pub fn set_end_latlng(&mut self, end_latlng: ::models::LatLng) {
    self.end_latlng = Some(end_latlng);
  }

  pub fn with_end_latlng(mut self, end_latlng: ::models::LatLng) -> ExplorerSegment {
    self.end_latlng = Some(end_latlng);
    self
  }

  pub fn end_latlng(&self) -> Option<&::models::LatLng> {
    self.end_latlng.as_ref()
  }

  pub fn reset_end_latlng(&mut self) {
    self.end_latlng = None;
  }

  pub fn set_elev_difference(&mut self, elev_difference: f32) {
    self.elev_difference = Some(elev_difference);
  }

  pub fn with_elev_difference(mut self, elev_difference: f32) -> ExplorerSegment {
    self.elev_difference = Some(elev_difference);
    self
  }

  pub fn elev_difference(&self) -> Option<&f32> {
    self.elev_difference.as_ref()
  }

  pub fn reset_elev_difference(&mut self) {
    self.elev_difference = None;
  }

  pub fn set_distance(&mut self, distance: f32) {
    self.distance = Some(distance);
  }

  pub fn with_distance(mut self, distance: f32) -> ExplorerSegment {
    self.distance = Some(distance);
    self
  }

  pub fn distance(&self) -> Option<&f32> {
    self.distance.as_ref()
  }

  pub fn reset_distance(&mut self) {
    self.distance = None;
  }

  pub fn set_points(&mut self, points: String) {
    self.points = Some(points);
  }

  pub fn with_points(mut self, points: String) -> ExplorerSegment {
    self.points = Some(points);
    self
  }

  pub fn points(&self) -> Option<&String> {
    self.points.as_ref()
  }

  pub fn reset_points(&mut self) {
    self.points = None;
  }

}



