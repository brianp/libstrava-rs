/* 
 * Strava API v3
 *
 * The [Swagger Playground](https://developers.strava.com/playground) is the easiest way to familiarize yourself with the Strava API by submitting HTTP requests and observing the responses before you write any client code. It will show what a response will look like with different endpoints depending on the authorization scope you receive from your athletes. To use the Playground, go to https://www.strava.com/settings/api and change your “Authorization Callback Domain” to developers.strava.com. Please note, we only support Swagger 2.0. There is a known issue where you can only select one scope at a time. For more information, please check the section “client code” at https://developers.strava.com/docs.
 *
 * OpenAPI spec version: 3.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct SummarySegment {
  /// The unique identifier of this segment
  #[serde(rename = "id")]
  id: Option<i64>,
  /// The name of this segment
  #[serde(rename = "name")]
  name: Option<String>,
  #[serde(rename = "activity_type")]
  activity_type: Option<String>,
  /// The segment's distance, in meters
  #[serde(rename = "distance")]
  distance: Option<f32>,
  /// The segment's average grade, in percents
  #[serde(rename = "average_grade")]
  average_grade: Option<f32>,
  /// The segments's maximum grade, in percents
  #[serde(rename = "maximum_grade")]
  maximum_grade: Option<f32>,
  /// The segments's highest elevation, in meters
  #[serde(rename = "elevation_high")]
  elevation_high: Option<f32>,
  /// The segments's lowest elevation, in meters
  #[serde(rename = "elevation_low")]
  elevation_low: Option<f32>,
  #[serde(rename = "start_latlng")]
  start_latlng: Option<::models::LatLng>,
  #[serde(rename = "end_latlng")]
  end_latlng: Option<::models::LatLng>,
  /// The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catégorie, 0 is uncategorized in climb_category.
  #[serde(rename = "climb_category")]
  climb_category: Option<i32>,
  /// The segments's city.
  #[serde(rename = "city")]
  city: Option<String>,
  /// The segments's state or geographical region.
  #[serde(rename = "state")]
  state: Option<String>,
  /// The segment's country.
  #[serde(rename = "country")]
  country: Option<String>,
  /// Whether this segment is private.
  #[serde(rename = "private")]
  private: Option<bool>,
  #[serde(rename = "athlete_pr_effort")]
  athlete_pr_effort: Option<::models::SummarySegmentEffort>
}

impl SummarySegment {
  pub fn new() -> SummarySegment {
    SummarySegment {
      id: None,
      name: None,
      activity_type: None,
      distance: None,
      average_grade: None,
      maximum_grade: None,
      elevation_high: None,
      elevation_low: None,
      start_latlng: None,
      end_latlng: None,
      climb_category: None,
      city: None,
      state: None,
      country: None,
      private: None,
      athlete_pr_effort: None
    }
  }

  pub fn set_id(&mut self, id: i64) {
    self.id = Some(id);
  }

  pub fn with_id(mut self, id: i64) -> SummarySegment {
    self.id = Some(id);
    self
  }

  pub fn id(&self) -> Option<&i64> {
    self.id.as_ref()
  }

  pub fn reset_id(&mut self) {
    self.id = None;
  }

  pub fn set_name(&mut self, name: String) {
    self.name = Some(name);
  }

  pub fn with_name(mut self, name: String) -> SummarySegment {
    self.name = Some(name);
    self
  }

  pub fn name(&self) -> Option<&String> {
    self.name.as_ref()
  }

  pub fn reset_name(&mut self) {
    self.name = None;
  }

  pub fn set_activity_type(&mut self, activity_type: String) {
    self.activity_type = Some(activity_type);
  }

  pub fn with_activity_type(mut self, activity_type: String) -> SummarySegment {
    self.activity_type = Some(activity_type);
    self
  }

  pub fn activity_type(&self) -> Option<&String> {
    self.activity_type.as_ref()
  }

  pub fn reset_activity_type(&mut self) {
    self.activity_type = None;
  }

  pub fn set_distance(&mut self, distance: f32) {
    self.distance = Some(distance);
  }

  pub fn with_distance(mut self, distance: f32) -> SummarySegment {
    self.distance = Some(distance);
    self
  }

  pub fn distance(&self) -> Option<&f32> {
    self.distance.as_ref()
  }

  pub fn reset_distance(&mut self) {
    self.distance = None;
  }

  pub fn set_average_grade(&mut self, average_grade: f32) {
    self.average_grade = Some(average_grade);
  }

  pub fn with_average_grade(mut self, average_grade: f32) -> SummarySegment {
    self.average_grade = Some(average_grade);
    self
  }

  pub fn average_grade(&self) -> Option<&f32> {
    self.average_grade.as_ref()
  }

  pub fn reset_average_grade(&mut self) {
    self.average_grade = None;
  }

  pub fn set_maximum_grade(&mut self, maximum_grade: f32) {
    self.maximum_grade = Some(maximum_grade);
  }

  pub fn with_maximum_grade(mut self, maximum_grade: f32) -> SummarySegment {
    self.maximum_grade = Some(maximum_grade);
    self
  }

  pub fn maximum_grade(&self) -> Option<&f32> {
    self.maximum_grade.as_ref()
  }

  pub fn reset_maximum_grade(&mut self) {
    self.maximum_grade = None;
  }

  pub fn set_elevation_high(&mut self, elevation_high: f32) {
    self.elevation_high = Some(elevation_high);
  }

  pub fn with_elevation_high(mut self, elevation_high: f32) -> SummarySegment {
    self.elevation_high = Some(elevation_high);
    self
  }

  pub fn elevation_high(&self) -> Option<&f32> {
    self.elevation_high.as_ref()
  }

  pub fn reset_elevation_high(&mut self) {
    self.elevation_high = None;
  }

  pub fn set_elevation_low(&mut self, elevation_low: f32) {
    self.elevation_low = Some(elevation_low);
  }

  pub fn with_elevation_low(mut self, elevation_low: f32) -> SummarySegment {
    self.elevation_low = Some(elevation_low);
    self
  }

  pub fn elevation_low(&self) -> Option<&f32> {
    self.elevation_low.as_ref()
  }

  pub fn reset_elevation_low(&mut self) {
    self.elevation_low = None;
  }

  pub fn set_start_latlng(&mut self, start_latlng: ::models::LatLng) {
    self.start_latlng = Some(start_latlng);
  }

  pub fn with_start_latlng(mut self, start_latlng: ::models::LatLng) -> SummarySegment {
    self.start_latlng = Some(start_latlng);
    self
  }

  pub fn start_latlng(&self) -> Option<&::models::LatLng> {
    self.start_latlng.as_ref()
  }

  pub fn reset_start_latlng(&mut self) {
    self.start_latlng = None;
  }

  pub fn set_end_latlng(&mut self, end_latlng: ::models::LatLng) {
    self.end_latlng = Some(end_latlng);
  }

  pub fn with_end_latlng(mut self, end_latlng: ::models::LatLng) -> SummarySegment {
    self.end_latlng = Some(end_latlng);
    self
  }

  pub fn end_latlng(&self) -> Option<&::models::LatLng> {
    self.end_latlng.as_ref()
  }

  pub fn reset_end_latlng(&mut self) {
    self.end_latlng = None;
  }

  pub fn set_climb_category(&mut self, climb_category: i32) {
    self.climb_category = Some(climb_category);
  }

  pub fn with_climb_category(mut self, climb_category: i32) -> SummarySegment {
    self.climb_category = Some(climb_category);
    self
  }

  pub fn climb_category(&self) -> Option<&i32> {
    self.climb_category.as_ref()
  }

  pub fn reset_climb_category(&mut self) {
    self.climb_category = None;
  }

  pub fn set_city(&mut self, city: String) {
    self.city = Some(city);
  }

  pub fn with_city(mut self, city: String) -> SummarySegment {
    self.city = Some(city);
    self
  }

  pub fn city(&self) -> Option<&String> {
    self.city.as_ref()
  }

  pub fn reset_city(&mut self) {
    self.city = None;
  }

  pub fn set_state(&mut self, state: String) {
    self.state = Some(state);
  }

  pub fn with_state(mut self, state: String) -> SummarySegment {
    self.state = Some(state);
    self
  }

  pub fn state(&self) -> Option<&String> {
    self.state.as_ref()
  }

  pub fn reset_state(&mut self) {
    self.state = None;
  }

  pub fn set_country(&mut self, country: String) {
    self.country = Some(country);
  }

  pub fn with_country(mut self, country: String) -> SummarySegment {
    self.country = Some(country);
    self
  }

  pub fn country(&self) -> Option<&String> {
    self.country.as_ref()
  }

  pub fn reset_country(&mut self) {
    self.country = None;
  }

  pub fn set_private(&mut self, private: bool) {
    self.private = Some(private);
  }

  pub fn with_private(mut self, private: bool) -> SummarySegment {
    self.private = Some(private);
    self
  }

  pub fn private(&self) -> Option<&bool> {
    self.private.as_ref()
  }

  pub fn reset_private(&mut self) {
    self.private = None;
  }

  pub fn set_athlete_pr_effort(&mut self, athlete_pr_effort: ::models::SummarySegmentEffort) {
    self.athlete_pr_effort = Some(athlete_pr_effort);
  }

  pub fn with_athlete_pr_effort(mut self, athlete_pr_effort: ::models::SummarySegmentEffort) -> SummarySegment {
    self.athlete_pr_effort = Some(athlete_pr_effort);
    self
  }

  pub fn athlete_pr_effort(&self) -> Option<&::models::SummarySegmentEffort> {
    self.athlete_pr_effort.as_ref()
  }

  pub fn reset_athlete_pr_effort(&mut self) {
    self.athlete_pr_effort = None;
  }

}



