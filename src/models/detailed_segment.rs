/* 
 * Strava API v3
 *
 * The [Swagger Playground](https://developers.strava.com/playground) is the easiest way to familiarize yourself with the Strava API by submitting HTTP requests and observing the responses before you write any client code. It will show what a response will look like with different endpoints depending on the authorization scope you receive from your athletes. To use the Playground, go to https://www.strava.com/settings/api and change your “Authorization Callback Domain” to developers.strava.com. Please note, we only support Swagger 2.0. There is a known issue where you can only select one scope at a time. For more information, please check the section “client code” at https://developers.strava.com/docs.
 *
 * OpenAPI spec version: 3.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct DetailedSegment {
  /// The unique identifier of this segment
  #[serde(rename = "id")]
  id: Option<i64>,
  /// The name of this segment
  #[serde(rename = "name")]
  name: Option<String>,
  #[serde(rename = "activity_type")]
  activity_type: Option<String>,
  /// The segment's distance, in meters
  #[serde(rename = "distance")]
  distance: Option<f32>,
  /// The segment's average grade, in percents
  #[serde(rename = "average_grade")]
  average_grade: Option<f32>,
  /// The segments's maximum grade, in percents
  #[serde(rename = "maximum_grade")]
  maximum_grade: Option<f32>,
  /// The segments's highest elevation, in meters
  #[serde(rename = "elevation_high")]
  elevation_high: Option<f32>,
  /// The segments's lowest elevation, in meters
  #[serde(rename = "elevation_low")]
  elevation_low: Option<f32>,
  #[serde(rename = "start_latlng")]
  start_latlng: Option<::models::LatLng>,
  #[serde(rename = "end_latlng")]
  end_latlng: Option<::models::LatLng>,
  /// The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catégorie, 0 is uncategorized in climb_category.
  #[serde(rename = "climb_category")]
  climb_category: Option<i32>,
  /// The segments's city.
  #[serde(rename = "city")]
  city: Option<String>,
  /// The segments's state or geographical region.
  #[serde(rename = "state")]
  state: Option<String>,
  /// The segment's country.
  #[serde(rename = "country")]
  country: Option<String>,
  /// Whether this segment is private.
  #[serde(rename = "private")]
  private: Option<bool>,
  #[serde(rename = "athlete_pr_effort")]
  athlete_pr_effort: Option<::models::SummarySegmentEffort>,
  /// The time at which the segment was created.
  #[serde(rename = "created_at")]
  created_at: Option<String>,
  /// The time at which the segment was last updated.
  #[serde(rename = "updated_at")]
  updated_at: Option<String>,
  /// The segment's total elevation gain.
  #[serde(rename = "total_elevation_gain")]
  total_elevation_gain: Option<f32>,
  #[serde(rename = "map")]
  map: Option<::models::PolylineMap>,
  /// The total number of efforts for this segment
  #[serde(rename = "effort_count")]
  effort_count: Option<i32>,
  /// The number of unique athletes who have an effort for this segment
  #[serde(rename = "athlete_count")]
  athlete_count: Option<i32>,
  /// Whether this segment is considered hazardous
  #[serde(rename = "hazardous")]
  hazardous: Option<bool>,
  /// The number of stars for this segment
  #[serde(rename = "star_count")]
  star_count: Option<i32>
}

impl DetailedSegment {
  pub fn new() -> DetailedSegment {
    DetailedSegment {
      id: None,
      name: None,
      activity_type: None,
      distance: None,
      average_grade: None,
      maximum_grade: None,
      elevation_high: None,
      elevation_low: None,
      start_latlng: None,
      end_latlng: None,
      climb_category: None,
      city: None,
      state: None,
      country: None,
      private: None,
      athlete_pr_effort: None,
      created_at: None,
      updated_at: None,
      total_elevation_gain: None,
      map: None,
      effort_count: None,
      athlete_count: None,
      hazardous: None,
      star_count: None
    }
  }

  pub fn set_id(&mut self, id: i64) {
    self.id = Some(id);
  }

  pub fn with_id(mut self, id: i64) -> DetailedSegment {
    self.id = Some(id);
    self
  }

  pub fn id(&self) -> Option<&i64> {
    self.id.as_ref()
  }

  pub fn reset_id(&mut self) {
    self.id = None;
  }

  pub fn set_name(&mut self, name: String) {
    self.name = Some(name);
  }

  pub fn with_name(mut self, name: String) -> DetailedSegment {
    self.name = Some(name);
    self
  }

  pub fn name(&self) -> Option<&String> {
    self.name.as_ref()
  }

  pub fn reset_name(&mut self) {
    self.name = None;
  }

  pub fn set_activity_type(&mut self, activity_type: String) {
    self.activity_type = Some(activity_type);
  }

  pub fn with_activity_type(mut self, activity_type: String) -> DetailedSegment {
    self.activity_type = Some(activity_type);
    self
  }

  pub fn activity_type(&self) -> Option<&String> {
    self.activity_type.as_ref()
  }

  pub fn reset_activity_type(&mut self) {
    self.activity_type = None;
  }

  pub fn set_distance(&mut self, distance: f32) {
    self.distance = Some(distance);
  }

  pub fn with_distance(mut self, distance: f32) -> DetailedSegment {
    self.distance = Some(distance);
    self
  }

  pub fn distance(&self) -> Option<&f32> {
    self.distance.as_ref()
  }

  pub fn reset_distance(&mut self) {
    self.distance = None;
  }

  pub fn set_average_grade(&mut self, average_grade: f32) {
    self.average_grade = Some(average_grade);
  }

  pub fn with_average_grade(mut self, average_grade: f32) -> DetailedSegment {
    self.average_grade = Some(average_grade);
    self
  }

  pub fn average_grade(&self) -> Option<&f32> {
    self.average_grade.as_ref()
  }

  pub fn reset_average_grade(&mut self) {
    self.average_grade = None;
  }

  pub fn set_maximum_grade(&mut self, maximum_grade: f32) {
    self.maximum_grade = Some(maximum_grade);
  }

  pub fn with_maximum_grade(mut self, maximum_grade: f32) -> DetailedSegment {
    self.maximum_grade = Some(maximum_grade);
    self
  }

  pub fn maximum_grade(&self) -> Option<&f32> {
    self.maximum_grade.as_ref()
  }

  pub fn reset_maximum_grade(&mut self) {
    self.maximum_grade = None;
  }

  pub fn set_elevation_high(&mut self, elevation_high: f32) {
    self.elevation_high = Some(elevation_high);
  }

  pub fn with_elevation_high(mut self, elevation_high: f32) -> DetailedSegment {
    self.elevation_high = Some(elevation_high);
    self
  }

  pub fn elevation_high(&self) -> Option<&f32> {
    self.elevation_high.as_ref()
  }

  pub fn reset_elevation_high(&mut self) {
    self.elevation_high = None;
  }

  pub fn set_elevation_low(&mut self, elevation_low: f32) {
    self.elevation_low = Some(elevation_low);
  }

  pub fn with_elevation_low(mut self, elevation_low: f32) -> DetailedSegment {
    self.elevation_low = Some(elevation_low);
    self
  }

  pub fn elevation_low(&self) -> Option<&f32> {
    self.elevation_low.as_ref()
  }

  pub fn reset_elevation_low(&mut self) {
    self.elevation_low = None;
  }

  pub fn set_start_latlng(&mut self, start_latlng: ::models::LatLng) {
    self.start_latlng = Some(start_latlng);
  }

  pub fn with_start_latlng(mut self, start_latlng: ::models::LatLng) -> DetailedSegment {
    self.start_latlng = Some(start_latlng);
    self
  }

  pub fn start_latlng(&self) -> Option<&::models::LatLng> {
    self.start_latlng.as_ref()
  }

  pub fn reset_start_latlng(&mut self) {
    self.start_latlng = None;
  }

  pub fn set_end_latlng(&mut self, end_latlng: ::models::LatLng) {
    self.end_latlng = Some(end_latlng);
  }

  pub fn with_end_latlng(mut self, end_latlng: ::models::LatLng) -> DetailedSegment {
    self.end_latlng = Some(end_latlng);
    self
  }

  pub fn end_latlng(&self) -> Option<&::models::LatLng> {
    self.end_latlng.as_ref()
  }

  pub fn reset_end_latlng(&mut self) {
    self.end_latlng = None;
  }

  pub fn set_climb_category(&mut self, climb_category: i32) {
    self.climb_category = Some(climb_category);
  }

  pub fn with_climb_category(mut self, climb_category: i32) -> DetailedSegment {
    self.climb_category = Some(climb_category);
    self
  }

  pub fn climb_category(&self) -> Option<&i32> {
    self.climb_category.as_ref()
  }

  pub fn reset_climb_category(&mut self) {
    self.climb_category = None;
  }

  pub fn set_city(&mut self, city: String) {
    self.city = Some(city);
  }

  pub fn with_city(mut self, city: String) -> DetailedSegment {
    self.city = Some(city);
    self
  }

  pub fn city(&self) -> Option<&String> {
    self.city.as_ref()
  }

  pub fn reset_city(&mut self) {
    self.city = None;
  }

  pub fn set_state(&mut self, state: String) {
    self.state = Some(state);
  }

  pub fn with_state(mut self, state: String) -> DetailedSegment {
    self.state = Some(state);
    self
  }

  pub fn state(&self) -> Option<&String> {
    self.state.as_ref()
  }

  pub fn reset_state(&mut self) {
    self.state = None;
  }

  pub fn set_country(&mut self, country: String) {
    self.country = Some(country);
  }

  pub fn with_country(mut self, country: String) -> DetailedSegment {
    self.country = Some(country);
    self
  }

  pub fn country(&self) -> Option<&String> {
    self.country.as_ref()
  }

  pub fn reset_country(&mut self) {
    self.country = None;
  }

  pub fn set_private(&mut self, private: bool) {
    self.private = Some(private);
  }

  pub fn with_private(mut self, private: bool) -> DetailedSegment {
    self.private = Some(private);
    self
  }

  pub fn private(&self) -> Option<&bool> {
    self.private.as_ref()
  }

  pub fn reset_private(&mut self) {
    self.private = None;
  }

  pub fn set_athlete_pr_effort(&mut self, athlete_pr_effort: ::models::SummarySegmentEffort) {
    self.athlete_pr_effort = Some(athlete_pr_effort);
  }

  pub fn with_athlete_pr_effort(mut self, athlete_pr_effort: ::models::SummarySegmentEffort) -> DetailedSegment {
    self.athlete_pr_effort = Some(athlete_pr_effort);
    self
  }

  pub fn athlete_pr_effort(&self) -> Option<&::models::SummarySegmentEffort> {
    self.athlete_pr_effort.as_ref()
  }

  pub fn reset_athlete_pr_effort(&mut self) {
    self.athlete_pr_effort = None;
  }

  pub fn set_created_at(&mut self, created_at: String) {
    self.created_at = Some(created_at);
  }

  pub fn with_created_at(mut self, created_at: String) -> DetailedSegment {
    self.created_at = Some(created_at);
    self
  }

  pub fn created_at(&self) -> Option<&String> {
    self.created_at.as_ref()
  }

  pub fn reset_created_at(&mut self) {
    self.created_at = None;
  }

  pub fn set_updated_at(&mut self, updated_at: String) {
    self.updated_at = Some(updated_at);
  }

  pub fn with_updated_at(mut self, updated_at: String) -> DetailedSegment {
    self.updated_at = Some(updated_at);
    self
  }

  pub fn updated_at(&self) -> Option<&String> {
    self.updated_at.as_ref()
  }

  pub fn reset_updated_at(&mut self) {
    self.updated_at = None;
  }

  pub fn set_total_elevation_gain(&mut self, total_elevation_gain: f32) {
    self.total_elevation_gain = Some(total_elevation_gain);
  }

  pub fn with_total_elevation_gain(mut self, total_elevation_gain: f32) -> DetailedSegment {
    self.total_elevation_gain = Some(total_elevation_gain);
    self
  }

  pub fn total_elevation_gain(&self) -> Option<&f32> {
    self.total_elevation_gain.as_ref()
  }

  pub fn reset_total_elevation_gain(&mut self) {
    self.total_elevation_gain = None;
  }

  pub fn set_map(&mut self, map: ::models::PolylineMap) {
    self.map = Some(map);
  }

  pub fn with_map(mut self, map: ::models::PolylineMap) -> DetailedSegment {
    self.map = Some(map);
    self
  }

  pub fn map(&self) -> Option<&::models::PolylineMap> {
    self.map.as_ref()
  }

  pub fn reset_map(&mut self) {
    self.map = None;
  }

  pub fn set_effort_count(&mut self, effort_count: i32) {
    self.effort_count = Some(effort_count);
  }

  pub fn with_effort_count(mut self, effort_count: i32) -> DetailedSegment {
    self.effort_count = Some(effort_count);
    self
  }

  pub fn effort_count(&self) -> Option<&i32> {
    self.effort_count.as_ref()
  }

  pub fn reset_effort_count(&mut self) {
    self.effort_count = None;
  }

  pub fn set_athlete_count(&mut self, athlete_count: i32) {
    self.athlete_count = Some(athlete_count);
  }

  pub fn with_athlete_count(mut self, athlete_count: i32) -> DetailedSegment {
    self.athlete_count = Some(athlete_count);
    self
  }

  pub fn athlete_count(&self) -> Option<&i32> {
    self.athlete_count.as_ref()
  }

  pub fn reset_athlete_count(&mut self) {
    self.athlete_count = None;
  }

  pub fn set_hazardous(&mut self, hazardous: bool) {
    self.hazardous = Some(hazardous);
  }

  pub fn with_hazardous(mut self, hazardous: bool) -> DetailedSegment {
    self.hazardous = Some(hazardous);
    self
  }

  pub fn hazardous(&self) -> Option<&bool> {
    self.hazardous.as_ref()
  }

  pub fn reset_hazardous(&mut self) {
    self.hazardous = None;
  }

  pub fn set_star_count(&mut self, star_count: i32) {
    self.star_count = Some(star_count);
  }

  pub fn with_star_count(mut self, star_count: i32) -> DetailedSegment {
    self.star_count = Some(star_count);
    self
  }

  pub fn star_count(&self) -> Option<&i32> {
    self.star_count.as_ref()
  }

  pub fn reset_star_count(&mut self) {
    self.star_count = None;
  }

}



